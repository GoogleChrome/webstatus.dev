// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package v1

import (
	"encoding/json"
	"sort"
	"time"

	"github.com/GoogleChrome/webstatus.dev/lib/generic"
)

// Change represents a value transition from Old to New.
type Change[T any] struct {
	From T `json:"from"`
	To   T `json:"to"`
}

// ChangeReason describes why a feature was added or removed.
type ChangeReason string

const (
	ReasonNewMatch  ChangeReason = "new_match"
	ReasonUnmatched ChangeReason = "unmatched"
	ReasonDeleted   ChangeReason = "deleted"
)

type SupportedBrowsers string

const (
	Chrome         SupportedBrowsers = "chrome"
	ChromeAndroid  SupportedBrowsers = "chrome_android"
	Edge           SupportedBrowsers = "edge"
	Firefox        SupportedBrowsers = "firefox"
	FirefoxAndroid SupportedBrowsers = "firefox_android"
	Safari         SupportedBrowsers = "safari"
	SafariIos      SupportedBrowsers = "safari_ios"
)

type BrowserImplementationStatus string

const (
	Available   BrowserImplementationStatus = "available"
	Unavailable BrowserImplementationStatus = "unavailable"
)

type BaselineInfoStatus string

const (
	Limited BaselineInfoStatus = "limited"
	Newly   BaselineInfoStatus = "newly"
	Widely  BaselineInfoStatus = "widely"
)

// These types represent the EVENT generated by comparing two States.
const (
	// KindFeatureListDiff identifies a delta report of feature changes.
	KindFeatureListDiff = "FeatureListDiff"
	// V1FeatureListDiff identifies version v1 of the FeatureListDiff schema.
	V1FeatureListDiff = "v1"
)

type FeatureDiffSnapshot struct {
	Metadata DiffMetadata `json:"metadata"`
	Data     FeatureDiff  `json:"data"`
}

func (d FeatureDiffSnapshot) Kind() string    { return KindFeatureListDiff }
func (d FeatureDiffSnapshot) Version() string { return V1FeatureListDiff }

type DiffMetadata struct {
	GeneratedAt     time.Time `json:"generatedAt"`
	EventID         string    `json:"eventId"`
	SearchID        string    `json:"searchId"`
	ID              string    `json:"id"`
	PreviousStateID string    `json:"previousStateId,omitempty"`
	NewStateID      string    `json:"newStateId"`
}

type FeatureDiff struct {
	QueryChanged bool              `json:"queryChanged,omitempty"`
	Added        []FeatureAdded    `json:"added,omitempty"`
	Removed      []FeatureRemoved  `json:"removed,omitempty"`
	Modified     []FeatureModified `json:"modified,omitempty"`
	Moves        []FeatureMoved    `json:"moves,omitempty"`
	Splits       []FeatureSplit    `json:"splits,omitempty"`
}

func (d *FeatureDiff) MarshalJSON() ([]byte, error) {
	d.Sort()

	return json.Marshal(d)
}

func (d *FeatureDiff) SetQueryChanged(changed bool) {
	d.QueryChanged = changed
}

// Sort orders all slices deterministically by Name (primary) and ID (secondary).
func (d *FeatureDiff) Sort() {
	sort.Slice(d.Added, func(i, j int) bool {
		if d.Added[i].Name != d.Added[j].Name {
			return d.Added[i].Name < d.Added[j].Name
		}

		return d.Added[i].ID < d.Added[j].ID
	})
	sort.Slice(d.Removed, func(i, j int) bool {
		if d.Removed[i].Name != d.Removed[j].Name {
			return d.Removed[i].Name < d.Removed[j].Name
		}

		return d.Removed[i].ID < d.Removed[j].ID
	})
	sort.Slice(d.Modified, func(i, j int) bool {
		if d.Modified[i].Name != d.Modified[j].Name {
			return d.Modified[i].Name < d.Modified[j].Name
		}

		return d.Modified[i].ID < d.Modified[j].ID
	})
	sort.Slice(d.Moves, func(i, j int) bool {
		if d.Moves[i].FromName != d.Moves[j].FromName {
			return d.Moves[i].FromName < d.Moves[j].FromName
		}

		return d.Moves[i].FromID < d.Moves[j].FromID
	})
	sort.Slice(d.Splits, func(i, j int) bool {
		if d.Splits[i].FromName != d.Splits[j].FromName {
			return d.Splits[i].FromName < d.Splits[j].FromName
		}

		return d.Splits[i].FromID < d.Splits[j].FromID
	})

	for k := range d.Splits {
		to := d.Splits[k].To
		sort.Slice(to, func(i, j int) bool {
			if to[i].Name != to[j].Name {
				return to[i].Name < to[j].Name
			}

			return to[i].ID < to[j].ID
		})
	}
}

type MdnDoc struct {
	URL   string  `json:"url,omitzero"`
	Title *string `json:"title,omitzero"`
	Slug  *string `json:"slug,omitzero"`
}

type Docs struct {
	MdnDocs []MdnDoc `json:"mdnDocs,omitzero"`
}

type FeatureAdded struct {
	ID     string       `json:"id"`
	Name   string       `json:"name"`
	Reason ChangeReason `json:"reason"`
	Docs   *Docs        `json:"docs,omitempty"`
}

type FeatureRemoved struct {
	ID     string       `json:"id"`
	Name   string       `json:"name"`
	Reason ChangeReason `json:"reason"`
}

type FeatureMoved struct {
	FromID   string `json:"fromId"`
	ToID     string `json:"toId"`
	FromName string `json:"fromName"`
	ToName   string `json:"toName"`
}

type FeatureSplit struct {
	FromID   string         `json:"fromId"`
	FromName string         `json:"fromName"`
	To       []FeatureAdded `json:"to"`
}

type FeatureModified struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Docs *Docs  `json:"docs,omitempty"`

	NameChange     *Change[string]                             `json:"nameChange,omitempty"`
	BaselineChange *Change[BaselineState]                      `json:"baselineChange,omitempty"`
	BrowserChanges map[SupportedBrowsers]*Change[BrowserState] `json:"browserChanges,omitempty"`
	DocsChange     *Change[Docs]                               `json:"docsChange,omitempty"`
}

type BrowserState struct {
	Status  generic.OptionallySet[BrowserImplementationStatus] `json:"status,omitzero"`
	Date    generic.OptionallySet[*time.Time]                  `json:"date,omitzero"`
	Version generic.OptionallySet[*string]                     `json:"version,omitzero"`
}

type BaselineState struct {
	Status   generic.OptionallySet[BaselineInfoStatus] `json:"status,omitzero"`
	LowDate  generic.OptionallySet[*time.Time]         `json:"lowDate,omitzero"`
	HighDate generic.OptionallySet[*time.Time]         `json:"highDate,omitzero"`
}

func (d FeatureDiff) HasChanges() bool {
	return d.HasQueryChanges() || d.HasDataChanges()
}

func (d FeatureDiff) HasDataChanges() bool {
	return len(d.Added) > 0 || len(d.Removed) > 0 ||
		len(d.Modified) > 0 || len(d.Moves) > 0 || len(d.Splits) > 0
}

func (d FeatureDiff) HasQueryChanges() bool {
	return d.QueryChanged
}
